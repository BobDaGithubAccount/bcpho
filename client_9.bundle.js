/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client_9.ts":
/*!*************************!*\
  !*** ./src/client_9.ts ***!
  \*************************/
/***/ (() => {

eval("\n(function () {\n    const canvas = document.getElementById('challenge9_canvas');\n    const ctx = canvas.getContext('2d');\n    ctx.translate(canvas.width / 2, canvas.height / 2);\n    const gravityInput = document.getElementById('challenge9_gravity');\n    const heightInput = document.getElementById('challenge9_height');\n    const speedInput = document.getElementById('challenge9_speed');\n    const angleInput = document.getElementById('challenge9_angle');\n    const dragCoefficientInput = document.getElementById('challenge9_dragCoefficient');\n    const airDensityInput = document.getElementById('challenge9_airDensity');\n    const areaInput = document.getElementById('challenge9_area');\n    const massInput = document.getElementById('challenge9_mass');\n    const corInput = document.getElementById('challenge9_cor');\n    const bounceInput = document.getElementById('challenge9_bounces');\n    const modeInput = document.getElementById('challenge9_mode');\n    const telemetry = document.getElementById('challenge9_telemetry');\n    let scale = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    let isDragging = false;\n    let startX, startY;\n    const draglessCurve = { points: [] };\n    const dragCurve = { points: [] };\n    let animationFrameId = null;\n    let telemetryArray = [];\n    function drawAxes() {\n        ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n        ctx.save();\n        ctx.translate(offsetX, offsetY);\n        ctx.scale(scale, scale);\n        ctx.beginPath();\n        ctx.moveTo(-canvas.width, 0);\n        ctx.lineTo(canvas.width, 0);\n        ctx.strokeStyle = 'black';\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(0, -canvas.height);\n        ctx.lineTo(0, canvas.height);\n        ctx.strokeStyle = 'black';\n        ctx.stroke();\n        ctx.restore();\n    }\n    function calculateTrajectory(withDrag) {\n        const g = parseFloat(gravityInput.value);\n        const h = parseFloat(heightInput.value);\n        const u = parseFloat(speedInput.value);\n        const angle = parseFloat(angleInput.value) * (Math.PI / 180);\n        const dragCoefficient = parseFloat(dragCoefficientInput.value);\n        const airDensity = parseFloat(airDensityInput.value);\n        const area = parseFloat(areaInput.value);\n        const mass = parseFloat(massInput.value);\n        const restitution = parseFloat(corInput.value);\n        const maxBounces = parseInt(bounceInput.value);\n        const timeStep = 0.01;\n        const points = [];\n        let vx = u * Math.cos(angle);\n        let vy = u * Math.sin(angle);\n        let x = 0;\n        let y = h;\n        let bounceCount = 0;\n        if (g === 0 || u === 0 || isNaN(g) || isNaN(u)) {\n            console.error(\"Invalid input values: gravity or speed cannot be zero or NaN\");\n            return points;\n        }\n        while (bounceCount <= maxBounces) {\n            if (withDrag) {\n                const v = Math.sqrt(vx * vx + vy * vy);\n                const dragForce = 0.5 * airDensity * v * v * dragCoefficient * area;\n                const dragAx = (dragForce / mass) * (vx / v);\n                const dragAy = (dragForce / mass) * (vy / v);\n                vx -= dragAx * timeStep;\n                vy -= dragAy * timeStep;\n            }\n            vy -= g * timeStep;\n            x += vx * timeStep;\n            y += vy * timeStep;\n            if (y <= 0) {\n                y = 0;\n                vy = -vy * restitution;\n                bounceCount++;\n            }\n            points.push({ x, y });\n            if (y < -canvas.height / 2) {\n                break;\n            }\n        }\n        return points;\n    }\n    function drawCurve(curve, color) {\n        if (!ctx)\n            return;\n        ctx.save();\n        ctx.translate(offsetX, offsetY);\n        ctx.scale(scale, scale);\n        ctx.beginPath();\n        for (let i = 0; i < curve.points.length; i++) {\n            const point = curve.points[i];\n            if (i === 0) {\n                ctx.moveTo(point.x, -point.y);\n            }\n            else {\n                ctx.lineTo(point.x, -point.y);\n            }\n        }\n        ctx.strokeStyle = color;\n        ctx.stroke();\n        ctx.restore();\n    }\n    function draw() {\n        telemetry.innerHTML = telemetryArray.join('<br>');\n        draglessCurve.points = calculateTrajectory(false);\n        dragCurve.points = calculateTrajectory(true);\n        drawAxes();\n        drawCurve(draglessCurve, 'blue');\n        drawCurve(dragCurve, 'red');\n        telemetryArray = [];\n    }\n    function animate() {\n        if (animationFrameId !== null) {\n            cancelAnimationFrame(animationFrameId);\n        }\n        const draglessPoints = calculateTrajectory(false);\n        const dragPoints = calculateTrajectory(true);\n        let index = 0;\n        function step() {\n            if (index < draglessPoints.length || index < dragPoints.length) {\n                ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n                drawAxes();\n                ctx.save();\n                ctx.translate(offsetX, offsetY);\n                ctx.scale(scale, scale);\n                ctx.beginPath();\n                for (let i = 0; i <= index && i < draglessPoints.length; i++) {\n                    const point = draglessPoints[i];\n                    if (i === 0) {\n                        ctx.moveTo(point.x, -point.y);\n                    }\n                    else {\n                        ctx.lineTo(point.x, -point.y);\n                    }\n                }\n                ctx.strokeStyle = 'blue';\n                ctx.stroke();\n                ctx.beginPath();\n                for (let i = 0; i <= index && i < dragPoints.length; i++) {\n                    const point = dragPoints[i];\n                    if (i === 0) {\n                        ctx.moveTo(point.x, -point.y);\n                    }\n                    else {\n                        ctx.lineTo(point.x, -point.y);\n                    }\n                }\n                ctx.strokeStyle = 'red';\n                ctx.stroke();\n                ctx.restore();\n                index++;\n                animationFrameId = requestAnimationFrame(step);\n            }\n            else {\n                animationFrameId = null;\n            }\n        }\n        step();\n    }\n    function handleMouseDown(e) {\n        isDragging = true;\n        startX = e.clientX - offsetX;\n        startY = e.clientY - offsetY;\n    }\n    function handleMouseMove(e) {\n        if (isDragging) {\n            offsetX = e.clientX - startX;\n            offsetY = e.clientY - startY;\n            draw();\n        }\n        const rect = canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left - canvas.width / 2 - offsetX) / scale;\n        const y = -(e.clientY - rect.top - canvas.height / 2 - offsetY) / scale;\n        draw();\n        ctx.save();\n        ctx.translate(offsetX, offsetY);\n        ctx.scale(scale, scale);\n        ctx.fillStyle = 'black';\n        const nearestDraglessPoint = draglessCurve.points.reduce((nearestPoint, point) => {\n            const distance = Math.abs(point.x - x);\n            if (distance < Math.abs(nearestPoint.x - x)) {\n                return point;\n            }\n            return nearestPoint;\n        }, draglessCurve.points[0]);\n        const nearestDragPoint = dragCurve.points.reduce((nearestPoint, point) => {\n            const distance = Math.abs(point.x - x);\n            if (distance < Math.abs(nearestPoint.x - x)) {\n                return point;\n            }\n            return nearestPoint;\n        }, dragCurve.points[0]);\n        ctx.beginPath();\n        ctx.arc(nearestDraglessPoint.x, -nearestDraglessPoint.y, 2, 0, 2 * Math.PI);\n        ctx.fillStyle = 'blue';\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(nearestDragPoint.x, -nearestDragPoint.y, 2, 0, 2 * Math.PI);\n        ctx.fillStyle = 'red';\n        ctx.fill();\n        ctx.restore();\n        telemetryArray.push(`<p1>Dragless (BLUE): x=${nearestDraglessPoint.x}, y=${nearestDraglessPoint.y}</p1>`);\n        telemetryArray.push(`<p1>Drag (RED): x=${nearestDragPoint.x}, y=${nearestDragPoint.y}</p1>`);\n    }\n    function handleMouseUp() {\n        isDragging = false;\n    }\n    function handleWheel(e) {\n        e.preventDefault();\n        const zoom = e.deltaY < 0 ? 1.1 : 0.9;\n        scale *= zoom;\n        draw();\n    }\n    function handleModeChange() {\n        if (modeInput.value === 'animation') {\n            animate();\n        }\n        else {\n            draw();\n        }\n    }\n    gravityInput.addEventListener('input', handleModeChange);\n    heightInput.addEventListener('input', handleModeChange);\n    speedInput.addEventListener('input', handleModeChange);\n    corInput.addEventListener('input', handleModeChange);\n    bounceInput.addEventListener('input', handleModeChange);\n    angleInput.addEventListener('input', handleModeChange);\n    modeInput.addEventListener('input', handleModeChange);\n    canvas.addEventListener('mousedown', handleMouseDown);\n    canvas.addEventListener('mousemove', handleMouseMove);\n    canvas.addEventListener('mouseup', handleMouseUp);\n    canvas.addEventListener('wheel', handleWheel);\n    handleModeChange();\n})();\n\n\n//# sourceURL=webpack://bcpho/./src/client_9.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/client_9.ts"]();
/******/ 	
/******/ })()
;