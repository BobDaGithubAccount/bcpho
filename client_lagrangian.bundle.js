/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client_lagrangian.ts":
/*!**********************************!*\
  !*** ./src/client_lagrangian.ts ***!
  \**********************************/
/***/ (() => {

eval("\n// import { create, all } from 'mathjs';\n// import numeric from 'numeric';\n// // Set up mathjs\n// const math = create(all);\n// // Define constants\n// const mass = 1; // mass of the projectile\n// const g = 9.81; // gravitational acceleration\n// const deltaT = 0.1; // time step\n// const learningRate = 0.01; // gradient descent learning rate\n// const iterations = 1000; // number of iterations\n// // Define the trajectory (initial guess)\n// const trajectory = {\n//     x: Array(100).fill(0).map((_, i) => i * 0.1),\n//     y: Array(100).fill(0).map((_, i) => 10 * Math.sin(i * 0.1))\n// };\n// // Define the kinetic and potential energy functions\n// function kineticEnergy(vx: number, vy: number, mass: number): number {\n//     return 0.5 * mass * (vx * vx + vy * vy);\n// }\n// function potentialEnergy(y: number, mass: number, g: number): number {\n//     return mass * g * y;\n// }\n// // Compute the action over the trajectory\n// function computeAction(trajectory: { x: number[], y: number[] }, deltaT: number, mass: number, g: number): number {\n//     let action = 0;\n//     for (let i = 0; i < trajectory.x.length - 1; i++) {\n//         const vx = (trajectory.x[i + 1] - trajectory.x[i]) / deltaT;\n//         const vy = (trajectory.y[i + 1] - trajectory.y[i]) / deltaT;\n//         const y = trajectory.y[i];\n//         const T = kineticEnergy(vx, vy, mass);\n//         const V = potentialEnergy(y, mass, g);\n//         const L = T - V; // Lagrangian\n//         action += L * deltaT;\n//     }\n//     return action;\n// }\n// // Compute the gradient numerically\n// function numericalGradient(trajectory: { x: number[], y: number[] }, deltaT: number, mass: number, g: number, epsilon: number = 1e-5): number[][] {\n//     const gradient: number[][] = [[], []];\n//     const baseAction = computeAction(trajectory, deltaT, mass, g);\n//     for (let i = 0; i < trajectory.x.length; i++) {\n//         // Perturb x\n//         const originalX = trajectory.x[i];\n//         trajectory.x[i] += epsilon;\n//         const perturbedActionX = computeAction(trajectory, deltaT, mass, g);\n//         gradient[0].push((perturbedActionX - baseAction) / epsilon);\n//         trajectory.x[i] = originalX;\n//         // Perturb y\n//         const originalY = trajectory.y[i];\n//         trajectory.y[i] += epsilon;\n//         const perturbedActionY = computeAction(trajectory, deltaT, mass, g);\n//         gradient[1].push((perturbedActionY - baseAction) / epsilon);\n//         trajectory.y[i] = originalY;\n//     }\n//     return gradient;\n// }\n// // Gradient descent algorithm\n// function gradientDescent(trajectory: { x: number[], y: number[] }, deltaT: number, mass: number, g: number, learningRate: number, iterations: number) {\n//     for (let iter = 0; iter < iterations; iter++) {\n//         const gradient = numericalGradient(trajectory, deltaT, mass, g);\n//         for (let i = 0; i < trajectory.x.length; i++) {\n//             trajectory.x[i] -= learningRate * gradient[0][i];\n//             trajectory.y[i] -= learningRate * gradient[1][i];\n//         }\n//         // Optionally print or log the action to monitor convergence\n//         if (iter % 100 === 0) {\n//             const action = computeAction(trajectory, deltaT, mass, g);\n//             console.log(`Iteration ${iter}: Action = ${action}`);\n//         }\n//     }\n// }\n// // Run the gradient descent\n// gradientDescent(trajectory, deltaT, mass, g, learningRate, iterations);\n// // Output final trajectory\n// console.log('Optimized trajectory:', trajectory);\n// // Function to draw the trajectory on the canvas\n// function drawTrajectory(trajectory: { x: number[], y: number[] }, canvasId: string) {\n//     const canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n//     if (!canvas) {\n//         console.error(`Canvas with id ${canvasId} not found`);\n//         return;\n//     }\n//     const ctx = canvas.getContext('2d');\n//     if (!ctx) {\n//         console.error('Failed to get canvas context');\n//         return;\n//     }\n//     // Clear the canvas\n//     ctx.clearRect(0, 0, canvas.width, canvas.height);\n//     // Draw the trajectory\n//     ctx.beginPath();\n//     ctx.moveTo(trajectory.x[0], canvas.height - trajectory.y[0]); // Start from the first point\n//     for (let i = 1; i < trajectory.x.length; i++) {\n//         ctx.lineTo(trajectory.x[i], canvas.height - trajectory.y[i]);\n//     }\n//     ctx.strokeStyle = 'blue';\n//     ctx.lineWidth = 2;\n//     ctx.stroke();\n// }\n// // Call the function to draw the optimized trajectory\n// drawTrajectory(trajectory, 'challenge_lagrangian_canvas');\n// // import { add, multiply, map, MathCollection } from 'mathjs';\n// // import Chart from 'chart.js/auto';\n// // // Constants\n// // const g = -9.81;  // Acceleration due to gravity (m/s^2)\n// // const m = 1.0;    // Mass of the projectile (kg)\n// // // Time discretization\n// // const N = 100;        // Number of time steps\n// // const tFinal = 2.0;   // Final time (s)\n// // const dt = tFinal / (N - 1);  // Time step size\n// // // Initial conditions\n// // const x0 = 0.0;\n// // const y0 = 0.0;\n// // const vx0 = 10.0;\n// // const vy0 = 10.0;\n// // // Define the system of differential equations\n// // function equationsOfMotion(t: number, state: number[]): number[] {\n// //     const [x, y, vx, vy] = state;\n// //     // Euler-Lagrange equations\n// //     const dvxdt = 0;  // No horizontal acceleration\n// //     const dvydt = g;  // Vertical acceleration due to gravity\n// //     const dxdt = vx;\n// //     const dydt = vy;\n// //     return [dxdt, dydt, dvxdt, dvydt];\n// // }\n// // // Runge-Kutta 4th order method\n// // function rungeKutta4(\n// //     f: (t: number, state: number[]) => number[], \n// //     y0: number[], \n// //     t0: number, \n// //     dt: number, \n// //     tFinal: number\n// // ): number[][] {\n// //     let t = t0;\n// //     let y = y0;\n// //     const result: number[][] = [y];\n// //     while (t < tFinal) {\n// //         const k1 = map(f(t, y), value => (value as number) * dt) as number[];\n// //         const k2 = map(f(t + dt / 2, add(y, map(k1, value => (value as number) / 2) as number[]) as number[]), value => (value as number) * dt) as number[];\n// //         const k3 = map(f(t + dt / 2, add(y, map(k2, value => (value as number) / 2) as number[]) as number[]), value => (value as number) * dt) as number[];\n// //         const k4 = map(f(t + dt, add(y, k3) as number[]), value => (value as number) * dt) as number[];\n// //         y = add(y, map(add(add(k1, multiply(2, k2) as number[]), add(multiply(2, k3) as number[], k4) as number[]), value => (value as number) / 6) as number[]) as number[];\n// //         t += dt;\n// //         result.push(y);\n// //     }\n// //     return result;\n// // }\n// // // Initial state array\n// // const Y0 = [x0, y0, vx0, vy0];\n// // // Numerical integration using Runge-Kutta 4th order method\n// // const result = rungeKutta4(equationsOfMotion, Y0, 0, dt, tFinal);\n// // // Extracting the solution\n// // const x = result.map(state => state[0]);\n// // const y = result.map(state => state[1]);\n// // // Plotting the results using Chart.js\n// // const ctx = (document.getElementById('challenge_lagrangian_canvas') as HTMLCanvasElement).getContext('2d');\n// // if (ctx) {\n// //     new Chart(ctx, {\n// //         type: 'line',\n// //         data: {\n// //             labels: x.map((_, i) => i * dt),\n// //             datasets: [{\n// //                 label: 'Trajectory',\n// //                 data: x.map((xValue, i) => ({ x: xValue, y: y[i] })),\n// //                 borderColor: 'blue',\n// //                 fill: false,\n// //             }],\n// //         },\n// //         options: {\n// //             scales: {\n// //                 x: { \n// //                     title: { text: 'x (m)', display: true },\n// //                     type: 'linear'\n// //                 },\n// //                 y: {\n// //                     title: { text: 'y (m)', display: true }\n// //                 }\n// //             }\n// //         }\n// //     });\n// // }\n\n\n//# sourceURL=webpack://bcpho/./src/client_lagrangian.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/client_lagrangian.ts"]();
/******/ 	
/******/ })()
;