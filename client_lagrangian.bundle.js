/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client_lagrangian.ts":
/*!**********************************!*\
  !*** ./src/client_lagrangian.ts ***!
  \**********************************/
/***/ (() => {

eval("\n// (async function() {\n// const canvas = document.getElementById('challenge1.5_canvas') as HTMLCanvasElement;\n// const ctx = canvas.getContext('2d')!;\n// ctx.translate(canvas.width / 2, canvas.height / 2);\n// const angleInput = document.getElementById('challenge1.5_angle') as HTMLInputElement;\n// const gravityInput = document.getElementById('challenge1.5_gravity') as HTMLInputElement;\n// const speedInput = document.getElementById('challenge1.5_speed') as HTMLInputElement;\n// const heightInput = document.getElementById('challenge1.5_height') as HTMLInputElement;\n// const startButton = document.getElementById('challenge1.5_startSimulation') as HTMLButtonElement;\n// let scale = 1;\n// let offsetX = 0;\n// let offsetY = 0;\n// let isDragging = false;\n// let startX: number, startY: number;\n// let points: { x: number, y: number }[] = [];\n// function drawAxes() {\n//     ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n//     ctx.save();\n//     ctx.translate(offsetX, offsetY);\n//     ctx.scale(scale, scale);\n//     ctx.beginPath();\n//     ctx.moveTo(-canvas.width, 0);\n//     ctx.lineTo(canvas.width, 0);\n//     ctx.strokeStyle = 'black';\n//     ctx.stroke();\n//     ctx.beginPath();\n//     ctx.moveTo(0, -canvas.height);\n//     ctx.lineTo(0, canvas.height);\n//     ctx.strokeStyle = 'black';\n//     ctx.stroke();\n//     ctx.restore();\n// }\n// function drawTrajectory() {\n//     const g: number = parseFloat(gravityInput.value) || 9.81; // gravity\n//     const m: number = 1; // mass (arbitrary unit)\n//     const Lagrangian = (x: number, y: number, vx: number, vy: number): number => {\n//         const T = 0.5 * m * (vx * vx + vy * vy); // kinetic energy\n//         const V = m * g * y; // potential energy\n//         return T - V;\n//     };\n//     const action = (trajectory: [number, number][]): number => {\n//         const dt = 0.01; // time step\n//         let S = 0;\n//         for (let i = 0; i < trajectory.length - 1; i++) {\n//             const [x, y] = trajectory[i];\n//             const [xNext, yNext] = trajectory[i + 1];\n//             const vx = (xNext - x) / dt;\n//             const vy = (yNext - y) / dt;\n//             S += Lagrangian(x, y, vx, vy) * dt;\n//         }\n//         return S;\n//     };\n//     const optimizeTrajectory = (initialTrajectory: [number, number][]): [number, number][] => {\n//         const learningRate = 0.001; // Reduced learning rate\n//         const maxIterations = 1000; // Increased number of iterations\n//         const convergenceThreshold = 1e-6;\n//         let trajectory = initialTrajectory.slice();\n//         for (let iter = 0; iter < maxIterations; iter++) {\n//             const grad: [number, number][] = new Array(trajectory.length).fill([0, 0]);\n//             let maxChange = 0;\n//             for (let i = 1; i < trajectory.length - 1; i++) {\n//                 const original: [number, number] = [...trajectory[i]];\n//                 // Compute gradient for x\n//                 trajectory[i][0] += 0.001;\n//                 const S1 = action(trajectory);\n//                 trajectory[i][0] -= 0.002;\n//                 const S2 = action(trajectory);\n//                 trajectory[i][0] = original[0];\n//                 grad[i] = [(S1 - S2) / 0.002, 0];\n//                 // Compute gradient for y\n//                 trajectory[i][1] += 0.001;\n//                 const S3 = action(trajectory);\n//                 trajectory[i][1] -= 0.002;\n//                 const S4 = action(trajectory);\n//                 trajectory[i][1] = original[1];\n//                 grad[i][1] = (S3 - S4) / 0.002;\n//             }\n//             for (let i = 1; i < trajectory.length - 1; i++) {\n//                 const changeX = learningRate * grad[i][0];\n//                 const changeY = learningRate * grad[i][1];\n//                 trajectory[i][0] -= changeX;\n//                 trajectory[i][1] -= changeY;\n//                 maxChange = Math.max(maxChange, Math.abs(changeX), Math.abs(changeY));\n//             }\n//             // Check for convergence\n//             if (maxChange < convergenceThreshold) {\n//                 console.log(`Converged after ${iter} iterations`);\n//                 break;\n//             }\n//         }\n//         return trajectory;\n//     };\n//     const initialTrajectory: [number, number][] = [];\n//     for (let t = 0; t <= 10; t += 0.1) { // Use a larger initial step for initialization\n//         initialTrajectory.push([t, 0]);\n//     }\n//     const optimizedTrajectory = optimizeTrajectory(initialTrajectory);\n//     console.log('Optimized Trajectory:', optimizedTrajectory);\n//     // Plot the trajectory\n//     ctx.save();\n//     ctx.translate(offsetX, offsetY);\n//     ctx.scale(scale, scale);\n//     ctx.beginPath();\n//     optimizedTrajectory.forEach(([x, y], index) => {\n//         if (index === 0) {\n//             ctx.moveTo(x, -y);\n//         } else {\n//             ctx.lineTo(x, -y);\n//         }\n//     });\n//     ctx.strokeStyle = 'red';\n//     ctx.stroke();\n//     ctx.restore();\n// }\n// function draw() {\n//     drawAxes();\n// }\n// function handleMouseDown(e: MouseEvent) {\n//     isDragging = true;\n//     startX = e.clientX - offsetX;\n//     startY = e.clientY - offsetY;\n// }\n// function handleMouseMove(e: MouseEvent) {\n//     if (isDragging) {\n//         offsetX = e.clientX - startX;\n//         offsetY = e.clientY - startY;\n//         draw();\n//     }\n//     const rect = canvas.getBoundingClientRect();\n//     const x = (e.clientX - rect.left - canvas.width / 2 - offsetX) / scale;\n//     const y = -(e.clientY - rect.top - canvas.height / 2 - offsetY) / scale;\n//     draw();\n//     ctx.save();\n//     ctx.translate(offsetX, offsetY);\n//     ctx.scale(scale, scale);\n//     ctx.fillStyle = 'black';\n//     if (points.length > 0) {\n//         const closestPoint = points.reduce((prev, curr) => Math.abs(curr.x - x) < Math.abs(prev.x - x) ? curr : prev);\n//         ctx.fillText(`(${Math.round(closestPoint.x * 1000) / 1000}, ${Math.round(closestPoint.y * 1000) / 1000}`, x, -y);\n//         ctx.beginPath();\n//         ctx.arc(closestPoint.x, -closestPoint.y, 2, 0, 2 * Math.PI);\n//         ctx.fillStyle = 'blue';\n//         ctx.fill();\n//     }\n//     ctx.restore();\n// }\n// function handleMouseUp() {\n//     isDragging = false;\n// }\n// function handleWheel(e: WheelEvent) {\n//     e.preventDefault();\n//     const zoom = e.deltaY < 0 ? 1.1 : 0.9;\n//     scale *= zoom;\n//     draw();\n// }\n// angleInput.addEventListener('input', draw);\n// gravityInput.addEventListener('input', draw);\n// speedInput.addEventListener('input', draw);\n// heightInput.addEventListener('input', draw);\n// canvas.addEventListener('mousedown', handleMouseDown);\n// canvas.addEventListener('mousemove', handleMouseMove);\n// canvas.addEventListener('mouseup', handleMouseUp);\n// canvas.addEventListener('wheel', handleWheel);\n// startButton.addEventListener('click', drawTrajectory);\n// draw();\n// })();\n\n\n//# sourceURL=webpack://bcpho/./src/client_lagrangian.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/client_lagrangian.ts"]();
/******/ 	
/******/ })()
;